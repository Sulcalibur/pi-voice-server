// Generated by CoffeeScript 1.10.0
(function() {
  var WaveformClient, getUserMedia, requestAnimationFrame, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  requestAnimationFrame = this.requestAnimationFrame || this.webkitRequestAnimationFrame;

  getUserMedia = (function(_this) {
    return function(dictionary, callback, error) {
      _this.navigator.getUserMedia = _this.navigator.getUserMedia || _this.navigator.webkitGetUserMedia;
      return _this.navigator.getUserMedia(dictionary, callback, error);
    };
  })(this);

  WaveformClient = (function() {
    var analyser, audioContext, buffer, canvas, canvasContext, jqCanvas, mediaStreamSource;

    buffer = new Float32Array(1024);

    jqCanvas = null;

    canvas = null;

    canvasContext = null;

    mediaStreamSource = null;

    analyser = null;

    audioContext = null;

    function WaveformClient(opts) {
      jqCanvas = opts.canvas;
      jqCanvas.css({
        opacity: 0
      });
      canvas = jqCanvas.get(0);
      canvas.width = window.innerWidth * 0.8;
      canvasContext = canvas.getContext("2d");
      audioContext = new AudioContext();
      getUserMedia({
        audio: {
          mandatory: {
            googEchoCancellation: false,
            googAutoGainControl: false,
            googNoiseSuppression: false,
            googHighpassFilter: false
          },
          optional: []
        }
      }, (function(_this) {
        return function(stream) {
          mediaStreamSource = audioContext.createMediaStreamSource(stream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          mediaStreamSource.connect(analyser);
          return _this.update();
        };
      })(this), function(ex) {
        return console.log("getUserMedia threw exception: " + ex);
      });
    }

    WaveformClient.prototype.update = function() {
      analyser.getFloatTimeDomainData(buffer);
      this.autoCorrelate(buffer, audioContext.sampleRate);
      return this.paintCanvas();
    };

    WaveformClient.prototype.autoCorrelate = function(buffer, sampleRate) {
      var MAX_SAMPLES, MIN_SAMPLES, SIZE, best_correlation, best_offset, correlation, correlations, foundGoodCorrelation, i, j, k, lastCorrelation, num, offset, ref, ref1, ref2, ref3, rms, shift, val;
      SIZE = buffer.length;
      MIN_SAMPLES = 0;
      MAX_SAMPLES = Math.floor(SIZE / 2);
      best_offset = -1;
      best_correlation = 0;
      rms = 0;
      foundGoodCorrelation = false;
      correlations = new Array(MAX_SAMPLES);
      for (num = i = 0, ref = SIZE; 0 <= ref ? i <= ref : i >= ref; num = 0 <= ref ? ++i : --i) {
        val = buffer[num];
        rms += val * val;
      }
      rms = Math.sqrt(rms / SIZE);
      if (rms < 0.01) {
        return -1;
      } else {
        lastCorrelation = 1;
        for (offset = j = ref1 = MIN_SAMPLES, ref2 = MAX_SAMPLES; ref1 <= ref2 ? j <= ref2 : j >= ref2; offset = ref1 <= ref2 ? ++j : --j) {
          correlation = 0;
          for (num = k = 0, ref3 = MAX_SAMPLES; 0 <= ref3 ? k <= ref3 : k >= ref3; num = 0 <= ref3 ? ++k : --k) {
            correlation += Math.abs(buffer[num] - buffer[num + offset]);
          }
          correlation = 1 - (correlation / MAX_SAMPLES);
          correlations[offset] = correlation;
          if (correlation > 0.9 && correlation > lastCorrelation) {
            foundGoodCorrelation = true;
            if (correlation > best_correlation) {
              best_correlation = correlation;
              best_offset = offset;
            }
          } else if (foundGoodCorrelation) {
            shift = (correlations[best_offset + 1] - correlations[best_offset - 1]) / correlations[best_offset];
            return sampleRate / (best_offset + (8 * shift));
          }
          lastCorrelation = correlation;
        }
        if (best_correlation > 0.01) {
          return sampleRate / best_offset;
        }
        return -1;
      }
    };

    WaveformClient.prototype.paintCanvas = function() {
      var base, dist, i, j, mid, num, part, volumeDupe, zoom;
      part = 100;
      base = (Math.PI / 2) / part;
      zoom = 1;
      volumeDupe = 100;
      dist = canvas.width / 512;
      mid = canvas.height / 2;
      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
      canvasContext.beginPath();
      canvasContext.lineTo(0, canvas.height / 2);
      for (num = i = 0; i <= 512; num = ++i) {
        if (num < part) {
          zoom = Math.sin(base * num);
        } else if (num > 512 - part) {
          zoom = Math.sin(base * Math.abs(num - 512));
        } else {
          zoom = 1;
        }
        canvasContext.lineTo(dist * num, mid + (zoom * (Math.abs(buffer[num] * volumeDupe))));
      }
      for (num = j = 0; j <= 512; num = ++j) {
        if (num < part) {
          zoom = Math.sin(base * num);
        } else if (num > 512 - part) {
          zoom = Math.sin(base * Math.abs(num - 512));
        } else {
          zoom = 1;
        }
        canvasContext.lineTo(dist * num, mid + (0 - (zoom * (Math.abs(buffer[num] * volumeDupe)))));
      }
      canvasContext.lineTo(canvas.width, mid);
      canvasContext.fillStyle = "rgba(255,255,255,0.8)";
      canvasContext.fill();
      return requestAnimationFrame((function(_this) {
        return function() {
          return _this.update();
        };
      })(this));
    };

    WaveformClient.prototype.show = function() {
      jqCanvas.stop();
      return jqCanvas.animate({
        opacity: 1
      }, 500);
    };

    WaveformClient.prototype.hide = function() {
      return jqCanvas.stop().css({
        opacity: 0
      });
    };

    return WaveformClient;

  })();

  root.WaveformClient = WaveformClient;

}).call(this);
